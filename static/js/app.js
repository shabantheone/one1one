// Content definitions for navigation sections
const sectionContent = {
    privacy: `
        <h2 class="text-success mb-4">Privacy Policy</h2>
        <p class="text-muted small">Last Updated: 15 June 2025</p>
        
        <p>Welcome to WhatsApp Full DP ("we", "our", or "us"). Your privacy is important to us. This Privacy Policy explains how we collect, use, and protect your information when you use our web application.</p>
        
        <h4 class="text-success mt-4">1. Information We Collect</h4>
        <p>We do not collect any personal data such as name, address, or phone number.</p>
        <p>Uploaded images are processed temporarily to fit WhatsApp DP size without cropping.</p>
        <p>We do not store or share your images on our servers. All processing is done securely and deleted automatically after use.</p>
        
        <h4 class="text-success mt-4">2. Use of Information</h4>
        <p>The image you upload is only used to generate a full-size WhatsApp DP.</p>
        <p>We do not use your images for any other purpose.</p>
        
        <h4 class="text-success mt-4">3. Cookies</h4>
        <p>Our site may use basic cookies to improve performance, but no tracking or personal information is stored.</p>
        
        <h4 class="text-success mt-4">4. Third-Party Services</h4>
        <p>We may use third-party services like analytics tools or image processing APIs, but none of them store your personal data.</p>
        
        <h4 class="text-success mt-4">5. Security</h4>
        <p>We take reasonable steps to protect your information. Your uploaded images are never stored or reused.</p>
        
        <h4 class="text-success mt-4">6. Children's Privacy</h4>
        <p>Our service is not intended for children under the age of 13. We do not knowingly collect data from minors.</p>
        
        <h4 class="text-success mt-4">7. Contact Us</h4>
        <p>If you have any questions about this Privacy Policy, you can email us at:</p>
        <p><strong>ðŸ“§ itstheone786@gmail.com</strong></p>
    `,
    
    about: `
        <h2 class="text-success mb-4">About WhatsApp Full DP</h2>
        
        <p>At WhatsApp Full DP, our goal is simple â€” we help you upload your full-size photo as your WhatsApp DP without any cropping, compression, or unwanted borders. We know how frustrating it is when a beautiful photo gets cut off â€” that's why we built this simple and fast tool.</p>
        
        <p>No filters, no ads, no nonsense. Just your photo â€” exactly the way you want it.</p>
        
        <p>Whether it's a group photo, a scenic view, or a solo portrait â€” upload it, and we'll make sure it fits perfectly as your DP.</p>
        
        <p><strong>Thank you for using WhatsApp Full DP!</strong></p>
    `,
    
    contact: `
        <h2 class="text-success mb-4">Contact Us</h2>
        
        <p>If you have any feedback, questions, or suggestions, feel free to reach out to us.</p>
        
        <p><strong>Email:</strong> itstheone786@gmail.com</p>
        
        <p>We usually respond within 24â€“48 hours.</p>
    `,
    
    terms: `
        <h2 class="text-success mb-4">Terms of Service</h2>
        <p class="text-muted small">Last Updated: 15 June 2025</p>
        
        <p>Welcome to WhatsApp Full DP. By accessing or using our web application, you agree to comply with and be bound by the following terms:</p>
        
        <h4 class="text-success mt-4">1. Use of Service</h4>
        <p>You may use our service only for lawful purposes and in accordance with these Terms.</p>
        <p>You agree not to use the service to upload any content that is unlawful, harmful, offensive, or infringes on anyone's rights.</p>
        
        <h4 class="text-success mt-4">2. Image Processing</h4>
        <p>Our service allows you to upload photos to resize and fit as full WhatsApp profile pictures without cropping.</p>
        <p>We do not store or share your uploaded images. All images are processed temporarily and deleted automatically.</p>
        
        <h4 class="text-success mt-4">3. Intellectual Property</h4>
        <p>All content, trademarks, and intellectual property related to WhatsApp Full DP are owned by us or our licensors.</p>
        <p>You agree not to copy, reproduce, or use any part of the service for commercial purposes without permission.</p>
        
        <h4 class="text-success mt-4">4. Disclaimer</h4>
        <p>The service is provided "as is" without warranties of any kind. We do not guarantee that the service will be error-free or uninterrupted.</p>
        <p>We are not responsible for any loss or damage arising from your use of the service.</p>
        
        <h4 class="text-success mt-4">5. Limitation of Liability</h4>
        <p>Under no circumstances shall WhatsApp Full DP be liable for any indirect, incidental, or consequential damages arising from the use of this service.</p>
        
        <h4 class="text-success mt-4">6. Changes to Terms</h4>
        <p>We reserve the right to update or modify these Terms at any time without prior notice.</p>
        <p>Continued use of the service after changes indicates your acceptance of the new Terms.</p>
        
        <h4 class="text-success mt-4">7. Governing Law</h4>
        <p>These Terms are governed by the laws of India.</p>
        
        <h4 class="text-success mt-4">8. Contact Us</h4>
        <p>If you have questions about these Terms, please email us at:</p>
        <p><strong>ðŸ“§ itstheone786@gmail.com</strong></p>
    `,
    
    howItWorks: `
        <h2 class="text-success mb-4">How It Works â€” WhatsApp Full DP</h2>
        
        <div class="row">
            <div class="col-md-6 mb-4">
                <div class="d-flex align-items-start">
                    <div class="bg-success text-white rounded-circle d-flex align-items-center justify-content-center me-3" style="width: 40px; height: 40px; min-width: 40px;">
                        <strong>1</strong>
                    </div>
                    <div>
                        <h5 class="text-success">Select Your Photo</h5>
                        <p>Click on the upload button to choose the photo you want to use as your WhatsApp profile picture. You can select any image from your device.</p>
                    </div>
                </div>
            </div>
            
            <div class="col-md-6 mb-4">
                <div class="d-flex align-items-start">
                    <div class="bg-success text-white rounded-circle d-flex align-items-center justify-content-center me-3" style="width: 40px; height: 40px; min-width: 40px;">
                        <strong>2</strong>
                    </div>
                    <div>
                        <h5 class="text-success">Choose the Style</h5>
                        <p>After uploading, select the style or aspect ratio that fits best for WhatsApp DP without cropping. Our tool automatically adjusts the image to maintain the full picture.</p>
                    </div>
                </div>
            </div>
            
            <div class="col-md-6 mb-4">
                <div class="d-flex align-items-start">
                    <div class="bg-success text-white rounded-circle d-flex align-items-center justify-content-center me-3" style="width: 40px; height: 40px; min-width: 40px;">
                        <strong>3</strong>
                    </div>
                    <div>
                        <h5 class="text-success">Generate Full DP</h5>
                        <p>Click on the "Generate" button and wait a moment. The app will process your photo to fit perfectly as a full WhatsApp profile picture.</p>
                    </div>
                </div>
            </div>
            
            <div class="col-md-6 mb-4">
                <div class="d-flex align-items-start">
                    <div class="bg-success text-white rounded-circle d-flex align-items-center justify-content-center me-3" style="width: 40px; height: 40px; min-width: 40px;">
                        <strong>4</strong>
                    </div>
                    <div>
                        <h5 class="text-success">Download and Use</h5>
                        <p>Download the processed full-size photo and set it as your WhatsApp DP. Enjoy your photo without any cuts or unwanted cropping!</p>
                    </div>
                </div>
            </div>
        </div>
    `
};

// Navigation functions
function showSection(sectionId) {
    const mainContent = document.getElementById('main-content');
    const dynamicContent = document.getElementById('dynamic-content');
    const contentArea = document.getElementById('content-area');
    
    if (sectionContent[sectionId]) {
        mainContent.classList.add('d-none');
        dynamicContent.classList.remove('d-none');
        contentArea.innerHTML = sectionContent[sectionId];
        
        // Scroll to top
        window.scrollTo(0, 0);
    }
}

function showHome() {
    const mainContent = document.getElementById('main-content');
    const dynamicContent = document.getElementById('dynamic-content');
    
    dynamicContent.classList.add('d-none');
    mainContent.classList.remove('d-none');
    
    // Scroll to top
    window.scrollTo(0, 0);
}

class ImageProcessor {
    constructor() {
        this.currentFileId = null;
        this.currentFilename = null;
        this.uploadFilename = null;
        this.pendingFile = null; // Store file waiting for option selection
        this.selectedOption = null; // No default option - user must select
        this.selectedColor = '#ffffff'; // Default color
        this.blurIntensity = 15; // Default blur intensity
        this.cropMode = null;
        this.cropData = null;
        this.isDragging = false;
        this.isResizing = false;
        this.startX = 0;
        this.startY = 0;
        this.initializeEventListeners();
        this.setupDragAndDrop();
    }

    initializeEventListeners() {
        this.setupEventListeners();
        this.setupNavigationLinks();
    }
    
    setupEventListeners() {
        const fileInput = document.getElementById('file-input');
        const downloadBtn = document.getElementById('download-btn');
        const uploadAnotherBtn = document.getElementById('upload-another-btn');

        if (fileInput) {
            fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
        }
        if (downloadBtn) {
            downloadBtn.addEventListener('click', () => this.downloadImage());
        }
        if (uploadAnotherBtn) {
            uploadAnotherBtn.addEventListener('click', () => this.resetInterface());
        }

        // Checkbox selection handlers
        document.querySelectorAll('.option-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', (e) => this.handleCheckboxChange(e.target));
        });

        // Color selection handlers
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', (e) => this.selectColor(e.currentTarget.dataset.color));
        });



        // Blur slider handler
        const blurSlider = document.getElementById('blur-slider');
        if (blurSlider) {
            blurSlider.addEventListener('input', (e) => this.updateBlurIntensity(e.target.value));
        }

        // Crop interface controls
        const applyCropBtn = document.getElementById('apply-crop');
        const cancelCropBtn = document.getElementById('cancel-crop');
        
        if (applyCropBtn) {
            applyCropBtn.addEventListener('click', () => this.applyCrop());
        }
        
        if (cancelCropBtn) {
            cancelCropBtn.addEventListener('click', () => this.cancelCrop());
        }
    }

    setupNavigationLinks() {
        // Handle navigation links to scroll to options
        document.querySelectorAll('.nav-link[href^="#option"]').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = e.currentTarget.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                    
                    // Highlight the option briefly
                    targetElement.style.backgroundColor = '#d1e7dd';
                    setTimeout(() => {
                        targetElement.style.backgroundColor = '';
                    }, 2000);
                }
                
                // Close the navbar on mobile
                const navbarCollapse = document.getElementById('navbarNav');
                if (navbarCollapse.classList.contains('show')) {
                    navbarCollapse.classList.remove('show');
                }
            });
        });
    }

    setupDragAndDrop() {
        const uploadArea = document.getElementById('upload-area');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });

        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                this.processFile(files[0]);
            }
        });
    }

    handleCheckboxChange(checkbox) {
        // Uncheck all other checkboxes (only one selection allowed)
        document.querySelectorAll('.option-checkbox').forEach(cb => {
            if (cb !== checkbox) {
                cb.checked = false;
                cb.closest('.option-line').classList.remove('selected');
            }
        });

        // Update selected state based on checkbox
        const optionLine = checkbox.closest('.option-line');
        if (checkbox.checked) {
            optionLine.classList.add('selected');
            this.selectedOption = optionLine.dataset.option;
            console.log('Selected option:', this.selectedOption);
        } else {
            optionLine.classList.remove('selected');
            this.selectedOption = null;
        }

        // Show/hide color options based on selection
        this.updateColorOptionsVisibility();

        // Remove any existing processing message
        const processingMessage = document.getElementById('processing-message');
        if (processingMessage) processingMessage.remove();
        // If we have a pending file, process it now
        if (this.pendingFile) {
            this.hideError();
            this.uploadFile(this.pendingFile);
            this.pendingFile = null;
        }
        // If we have a file already uploaded, reprocess with selected option
        else if (this.currentFileId && this.uploadFilename) {
            this.processSelectedStyle();
        }
    }
    
    processSelectedStyle() {
        if (!this.selectedOption || !this.currentFileId || !this.uploadFilename) {
            return;
        }
        
        switch (this.selectedOption) {
            case 'full-resize':
                this.reprocessImage('stretch');
                break;
            case 'crop-colors':
                this.updateColorOptionsVisibility();
                if (this.selectedColor) {
                    this.reprocessImage('fit', this.selectedColor);
                }
                break;
            case 'set-blur':
                this.reprocessImage('blur', null, this.blurIntensity);
                break;
            case 'center-left-right':
                this.reprocessImage('center-left-right');
                break;
            case 'left-right-center':
                this.reprocessImage('left-right-center');
                break;
            default:
                console.log('Unknown option:', this.selectedOption);
        }
    }

    selectColor(color) {
        // Remove selected class from all color buttons
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.classList.remove('selected');
        });

        // Add selected class to clicked color
        const selectedColorBtn = document.querySelector(`[data-color="${color}"]`);
        if (selectedColorBtn) {
            selectedColorBtn.classList.add('selected');
        }

        this.selectedColor = color;
        console.log('Selected color:', this.selectedColor);

        // Update custom color picker value
        const customColorPicker = document.getElementById('custom-color');
        if (customColorPicker) {
            customColorPicker.value = color;
        }

        // If we have a file uploaded and color option is selected, reprocess with new color
        if (this.currentFileId && this.selectedOption === 'crop-colors') {
            this.reprocessImage('fit', this.selectedColor);
        }
    }

    updateColorOptionsVisibility() {
        // Show color options only for crop-colors option
        const colorOptions = document.querySelector('#option-crop-colors .color-options');
        const blurOptions = document.querySelector('#option-set-blur .blur-options');
        
        if (this.selectedOption === 'crop-colors') {
            if (colorOptions) colorOptions.style.display = 'block';
        } else {
            if (colorOptions) colorOptions.style.display = 'none';
        }
        
        if (this.selectedOption === 'set-blur') {
            if (blurOptions) blurOptions.style.display = 'block';
        } else {
            if (blurOptions) blurOptions.style.display = 'none';
        }
    }

    processWithSelectedOption() {
        // Update the processed title based on selected option
        const processedTitle = document.getElementById('processed-title');
        if (!processedTitle) return;

        switch (this.selectedOption) {
            case 'full-resize':
                processedTitle.textContent = 'SET FULL DP AS IT IS - Stretched to Square';
                break;
            case 'crop-colors':
                processedTitle.textContent = `Set Dp With ${this.selectedColor} Background`;
                break;
            case 'crop-blur':
                processedTitle.textContent = 'Set Dp With Blur Background';
                break;
            case 'center-resize':
                processedTitle.textContent = 'Center Same Left Right Resize';
                break;
            case 'side-center':
                processedTitle.textContent = 'Left Right Same Center Resize';
                break;
            default:
                processedTitle.textContent = 'Processed Image';
        }
    }

    handleFileSelect(event) {
        const file = event.target.files[0];
        if (file) {
            this.processFile(file);
        }
    }

    processFile(file) {
        // Validate file type
        if (!this.isValidFileType(file)) {
            this.showError('Please select a JPG or PNG file.');
            return;
        }

        // Validate file size (16MB limit)
        if (file.size > 16 * 1024 * 1024) {
            this.showError('File size must be less than 16MB.');
            return;
        }

        this.hideError();
        
        // Always show photo preview immediately in upload area
        this.showOriginalPreview(file);
        
        // If an option is selected, upload and process immediately
        if (this.selectedOption) {
            this.uploadFile(file);
        } else {
            // Store file for later processing when option is selected
            this.pendingFile = file;
        }
    }

    isValidFileType(file) {
        const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png'];
        return allowedTypes.includes(file.type);
    }

    uploadFile(file) {
        const formData = new FormData();
        formData.append('file', file);
        
        // Add processing parameters based on selected option
        if (this.selectedOption === 'full-resize') {
            formData.append('mode', 'stretch');
        } else if (this.selectedOption === 'crop-colors') {
            formData.append('mode', 'fit');
            formData.append('bg_color', this.selectedColor);
        } else if (this.selectedOption === 'set-blur') {
            formData.append('mode', 'blur');
            formData.append('blur_intensity', this.blurIntensity);
        } else if (this.selectedOption === 'crop-square') {
            formData.append('mode', 'crop-square');
            if (this.cropData) {
                formData.append('crop_data', JSON.stringify(this.cropData));
            }
        } else if (this.selectedOption === 'crop-circle') {
            formData.append('mode', 'crop-circle');
            if (this.cropData) {
                formData.append('crop_data', JSON.stringify(this.cropData));
            }
        } else {
            formData.append('mode', 'stretch'); // Default
        }

        this.showProgress();

        fetch('/upload', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                this.currentFileId = data.file_id;
                this.currentFilename = data.processed_filename;
                this.uploadFilename = data.upload_filename;
                this.hideProgress();
                
                // Show processed image
                this.showProcessedImage(data.processed_filename);
            } else {
                this.showError(data.error || 'Failed to process image');
                this.hideProgress();
            }
        })
        .catch(error => {
            console.error('Error:', error);
            this.showError('Failed to upload file. Please try again.');
            this.hideProgress();
        });
    }

    showOriginalPreview(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            // Store reference to file input before modifying DOM
            const fileInput = document.getElementById('file-input');
            const uploadArea = document.getElementById('upload-area');
            
            if (uploadArea && fileInput) {
                uploadArea.innerHTML = `
                    <div class="side-by-side-preview">
                        <div class="original-side">
                            <img src="${e.target.result}" alt="Original image" class="preview-img">
                            <button type="button" class="btn btn-outline-success btn-sm mt-2" id="change-photo-btn">
                                <i class="fas fa-exchange-alt me-2"></i>Change Photo
                            </button>
                        </div>
                        <div class="processed-side">
                            <div class="processing-message">
                                <p class="text-muted">Choose your processing style below</p>
                            </div>
                        </div>
                    </div>
                `;
                
                // Re-append the file input to maintain its functionality
                uploadArea.appendChild(fileInput);
                
                // Add event listener to the new change photo button
                const changePhotoBtn = document.getElementById('change-photo-btn');
                if (changePhotoBtn) {
                    changePhotoBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Change photo button clicked');
                        fileInput.click();
                    });
                }
            }
        };
        reader.readAsDataURL(file);
    }

    showProcessedImage(filename) {
        // Show processed image in the right side of the preview area
        const processedSide = document.querySelector('.processed-side');
        
        if (processedSide) {
            processedSide.innerHTML = `
                <img src="/preview/${filename}?t=${Date.now()}" alt="Processed image" class="preview-img">
                <button type="button" class="btn btn-success btn-sm mt-2" onclick="imageProcessor.downloadImage()">
                    <i class="fas fa-download me-2"></i>Download
                </button>
            `;
        }
    }

    updateBlurIntensity(value) {
        this.blurIntensity = parseInt(value);
        console.log('Blur intensity:', this.blurIntensity);
        
        // If we have an image and blur option is selected, reprocess immediately
        if (this.currentFileId && this.uploadFilename && this.selectedOption === 'set-blur') {
            this.reprocessImage('blur', null, this.blurIntensity);
        }
    }



    downloadImage() {
        if (this.currentFilename) {
            const link = document.createElement('a');
            link.href = `/download/${this.currentFilename}`;
            link.download = `whatsapp_profile_${this.currentFilename}`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    }

    showProgress() {
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        
        progressContainer.classList.remove('d-none');
        
        // Instant progress display - no animation delay
        progressBar.style.width = '95%';
        progressText.textContent = 'Processing...';
    }

    hideProgress() {
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        
        // Complete the progress bar
        progressBar.style.width = '100%';
        progressText.textContent = '100%';
        
        setTimeout(() => {
            progressContainer.classList.add('d-none');
            progressBar.style.width = '0%';
            progressText.textContent = '0%';
        }, 500);
    }

    showError(message) {
        const errorAlert = document.getElementById('error-alert');
        const errorMessage = document.getElementById('error-message');
        
        errorMessage.textContent = message;
        errorAlert.classList.remove('d-none');
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
            this.hideError();
        }, 5000);
    }

    hideError() {
        const errorAlert = document.getElementById('error-alert');
        errorAlert.classList.add('d-none');
    }



    resetInterface() {
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('file-input');
        
        // Reset form safely
        if (fileInput) {
            fileInput.value = '';
        }
        this.currentFileId = null;
        this.currentFilename = null;
        this.uploadFilename = null;
        this.pendingFile = null;
        this.selectedOption = null;
        this.selectedColor = '#ffffff';
        
        // Hide error and progress
        this.hideError();
        this.hideProgress();
        
        // Reset option selection and checkboxes
        document.querySelectorAll('.option-checkbox').forEach(checkbox => {
            checkbox.checked = false;
        });
        document.querySelectorAll('.option-line').forEach(line => {
            line.classList.remove('selected');
        });
        
        // Reset color selection
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        
        // Hide color options
        this.updateColorOptionsVisibility();
        
        // Restore original upload interface
        if (uploadArea) {
            // Store reference to existing file input if it exists
            let existingFileInput = document.getElementById('file-input');
            
            uploadArea.innerHTML = `
                <div class="upload-content">
                    <i class="fas fa-cloud-upload-alt fa-4x text-success mb-3"></i>
                    <h4 class="mb-3">Choose Your Photo</h4>
                    <p class="text-muted mb-3">Drop your image here or click to browse</p>
                    <p class="text-muted small">Supports JPG and PNG files up to 16MB</p>
                    <button type="button" class="btn btn-success btn-lg mt-3" id="choose-photo-btn">
                        <i class="fas fa-folder-open me-2"></i>
                        Choose Your Photo
                    </button>
                </div>
            `;
            
            // Create new file input or reuse existing one
            if (!existingFileInput) {
                existingFileInput = document.createElement('input');
                existingFileInput.type = 'file';
                existingFileInput.id = 'file-input';
                existingFileInput.accept = '.jpg,.jpeg,.png';
                existingFileInput.className = 'd-none';
            } else {
                existingFileInput.value = ''; // Clear previous selection
            }
            
            // Append file input to upload area
            uploadArea.appendChild(existingFileInput);
            
            // Add event listener to choose photo button
            const choosePhotoBtn = document.getElementById('choose-photo-btn');
            if (choosePhotoBtn) {
                choosePhotoBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    existingFileInput.click();
                });
            }
            
            // Re-attach event listeners safely
            this.setupEventListeners();
        }
        
        // Remove ALL extra sections that might appear
        const extraSections = [
            'processed-result',
            'processing-message', 
            'preview-section',
            'processed-section'
        ];
        
        extraSections.forEach(sectionId => {
            const section = document.getElementById(sectionId);
            if (section) section.remove();
        });
        
        // Also remove any dynamically created sections
        document.querySelectorAll('.processed-preview-container, .alert-info, .mt-4.text-center').forEach(el => {
            if (el.parentNode) el.parentNode.removeChild(el);
        });
    }

    reprocessImage(mode, bgColor = '#ffffff', blurIntensity = 15) {
        if (!this.currentFileId || !this.uploadFilename) {
            this.showError('No image available for reprocessing');
            return;
        }

        this.showProgress();

        const requestData = {
            file_id: this.currentFileId,
            upload_filename: this.uploadFilename,
            mode: mode,
            bg_color: bgColor,
            blur_intensity: blurIntensity
        };

        fetch('/reprocess', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestData)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                this.currentFilename = data.processed_filename;
                this.showProcessedImage(data.processed_filename);
                this.hideProgress();
            } else {
                this.showError(data.error || 'Failed to reprocess image');
                this.hideProgress();
            }
        })
        .catch(error => {
            console.error('Error:', error);
            this.showError('Failed to reprocess image. Please try again.');
            this.hideProgress();
        });
    }

    // Cropping functionality methods
    startCropping(cropMode) {
        this.cropMode = cropMode;
        if (this.pendingFile) {
            this.showOriginalPreview(this.pendingFile);
            setTimeout(() => this.showCropInterface(cropMode), 100);
        }
    }

    showCropInterface(cropMode) {
        console.log('Showing crop interface for:', cropMode);
        this.cropMode = cropMode;
        const cropInterface = document.getElementById('crop-interface');
        const canvas = document.getElementById('crop-canvas');
        const cropBox = document.getElementById('crop-box');
        
        if (!cropInterface || !canvas || !cropBox) {
            console.error('Crop interface elements not found');
            this.showError('Crop interface not available. Please refresh the page.');
            return;
        }
        
        // Show interface immediately
        cropInterface.style.display = 'flex';
        cropInterface.style.visibility = 'visible';
        cropInterface.style.opacity = '1';
        cropInterface.style.position = 'fixed';
        cropInterface.style.zIndex = '9999';
        cropInterface.style.top = '0';
        cropInterface.style.left = '0';
        cropInterface.style.width = '100vw';
        cropInterface.style.height = '100vh';
        cropInterface.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        document.body.style.overflow = 'hidden';
        console.log('Crop interface displayed immediately');
        
        const ctx = canvas.getContext('2d');
        
        let imageSrc;
        if (this.pendingFile) {
            imageSrc = URL.createObjectURL(this.pendingFile);
            console.log('Using pending file for crop');
        } else if (this.uploadFilename) {
            imageSrc = `/uploads/${this.uploadFilename}`;
            console.log('Using uploaded file for crop:', this.uploadFilename);
        } else {
            this.showError('No image available for cropping');
            return;
        }

        const img = new Image();
        img.onload = () => {
            console.log('Image loading complete, setting up crop interface');
            const maxWidth = 600;
            const maxHeight = 400;
            let { width, height } = img;
            
            if (width > maxWidth || height > maxHeight) {
                const ratio = Math.min(maxWidth / width, maxHeight / height);
                width *= ratio;
                height *= ratio;
            }
            
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            ctx.drawImage(img, 0, 0, width, height);
            console.log('Image drawn on canvas');
            
            const boxSize = Math.min(width, height) * 0.6;
            const x = (width - boxSize) / 2;
            const y = (height - boxSize) / 2;
            console.log('Crop box position:', x, y, 'size:', boxSize);
            
            cropBox.style.left = x + 'px';
            cropBox.style.top = y + 'px';
            cropBox.style.width = boxSize + 'px';
            cropBox.style.height = boxSize + 'px';
            
            if (cropMode === 'crop-circle') {
                cropBox.classList.add('circle');
            } else {
                cropBox.classList.remove('circle');
            }
            
            this.setupCropInteraction();
        };
        
        img.onerror = () => {
            console.error('Failed to load image for crop:', imageSrc);
            // Show crop interface anyway with placeholder
            const canvas = document.getElementById('crop-canvas');
            const cropBox = document.getElementById('crop-box');
            const ctx = canvas.getContext('2d');
            
            // Set default canvas size
            canvas.width = 400;
            canvas.height = 300;
            canvas.style.width = '400px';
            canvas.style.height = '300px';
            
            // Fill with gray background
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, 400, 300);
            ctx.fillStyle = '#666';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Image Loading...', 200, 150);
            
            // Set up crop box
            const boxSize = 200;
            const x = (400 - boxSize) / 2;
            const y = (300 - boxSize) / 2;
            
            cropBox.style.left = x + 'px';
            cropBox.style.top = y + 'px';
            cropBox.style.width = boxSize + 'px';
            cropBox.style.height = boxSize + 'px';
            
            if (this.cropMode === 'crop-circle') {
                cropBox.classList.add('circle');
            } else {
                cropBox.classList.remove('circle');
            }
            
            this.setupCropInteraction();
        };
        
        console.log('Loading image for crop:', imageSrc);
        img.src = imageSrc;
    }

    setupCropInteraction() {
        const cropBox = document.getElementById('crop-box');
        const handles = document.querySelectorAll('.crop-handle');
        
        // Remove existing listeners to prevent duplicates
        if (this.mouseMoveHandler) {
            document.removeEventListener('mousemove', this.mouseMoveHandler);
            document.removeEventListener('mouseup', this.mouseUpHandler);
        }
        
        // Reset interaction state
        this.isDragging = false;
        this.isResizing = false;
        
        this.cropBoxMouseDown = (e) => {
            if (e.target.classList.contains('crop-handle')) return;
            
            this.isDragging = true;
            this.startX = e.clientX - cropBox.offsetLeft;
            this.startY = e.clientY - cropBox.offsetTop;
            e.preventDefault();
        };
        
        cropBox.addEventListener('mousedown', this.cropBoxMouseDown);
        
        handles.forEach(handle => {
            handle.addEventListener('mousedown', (e) => {
                this.isResizing = true;
                this.resizeHandle = handle.className.split(' ')[1];
                this.startX = e.clientX;
                this.startY = e.clientY;
                this.startWidth = cropBox.offsetWidth;
                this.startHeight = cropBox.offsetHeight;
                this.startLeft = cropBox.offsetLeft;
                this.startTop = cropBox.offsetTop;
                e.preventDefault();
                e.stopPropagation();
            });
        });
        
        this.mouseMoveHandler = (e) => this.handleMouseMove(e);
        this.mouseUpHandler = () => this.handleMouseUp();
        
        document.addEventListener('mousemove', this.mouseMoveHandler);
        document.addEventListener('mouseup', this.mouseUpHandler);
    }

    handleMouseMove(e) {
        const cropBox = document.getElementById('crop-box');
        const canvas = document.getElementById('crop-canvas');
        
        if (this.isDragging) {
            const rect = canvas.getBoundingClientRect();
            const newX = Math.max(0, Math.min(e.clientX - this.startX, canvas.width - cropBox.offsetWidth));
            const newY = Math.max(0, Math.min(e.clientY - this.startY, canvas.height - cropBox.offsetHeight));
            
            cropBox.style.left = newX + 'px';
            cropBox.style.top = newY + 'px';
        }
        
        if (this.isResizing) {
            const deltaX = e.clientX - this.startX;
            const deltaY = e.clientY - this.startY;
            
            const delta = Math.max(deltaX, deltaY);
            let newWidth = Math.max(50, Math.min(300, this.startWidth + delta));
            let newHeight = newWidth; // Keep square
            let newLeft = this.startLeft;
            let newTop = this.startTop;
            
            if (this.resizeHandle.includes('nw')) {
                newLeft = this.startLeft - (newWidth - this.startWidth);
                newTop = this.startTop - (newHeight - this.startHeight);
            } else if (this.resizeHandle.includes('ne')) {
                newTop = this.startTop - (newHeight - this.startHeight);
            } else if (this.resizeHandle.includes('sw')) {
                newLeft = this.startLeft - (newWidth - this.startWidth);
            }
            
            // Constrain to canvas bounds
            newLeft = Math.max(0, Math.min(newLeft, canvas.width - newWidth));
            newTop = Math.max(0, Math.min(newTop, canvas.height - newHeight));
            
            cropBox.style.left = newLeft + 'px';
            cropBox.style.top = newTop + 'px';
            cropBox.style.width = newWidth + 'px';
            cropBox.style.height = newHeight + 'px';
        }
    }

    handleMouseUp() {
        this.isDragging = false;
        this.isResizing = false;
    }

    applyCrop() {
        const cropBox = document.getElementById('crop-box');
        const canvas = document.getElementById('crop-canvas');
        
        this.cropData = {
            x: parseInt(cropBox.style.left),
            y: parseInt(cropBox.style.top),
            width: cropBox.offsetWidth,
            height: cropBox.offsetHeight,
            canvasWidth: canvas.width,
            canvasHeight: canvas.height,
            type: this.cropMode
        };
        
        document.getElementById('crop-interface').style.display = 'none';
        
        if (this.mouseMoveHandler) {
            document.removeEventListener('mousemove', this.mouseMoveHandler);
            document.removeEventListener('mouseup', this.mouseUpHandler);
            this.mouseMoveHandler = null;
            this.mouseUpHandler = null;
        }
        
        if (this.pendingFile) {
            this.uploadFile(this.pendingFile);
            this.pendingFile = null;
        } else if (this.currentFileId) {
            this.reprocessImage(this.cropMode, '#ffffff', 15);
        }
    }

    cancelCrop() {
        const cropInterface = document.getElementById('crop-interface');
        cropInterface.style.display = 'none';
        cropInterface.style.visibility = 'hidden';
        cropInterface.style.opacity = '0';
        document.body.style.overflow = 'auto';
        
        this.cropData = null;
        this.cropMode = null;
        
        if (this.mouseMoveHandler) {
            document.removeEventListener('mousemove', this.mouseMoveHandler);
            document.removeEventListener('mouseup', this.mouseUpHandler);
            this.mouseMoveHandler = null;
            this.mouseUpHandler = null;
        }
        
        if (this.selectedOption && this.selectedOption.includes('crop')) {
            const checkbox = document.querySelector(`#checkbox-${this.selectedOption}`);
            if (checkbox) {
                checkbox.checked = false;
                checkbox.closest('.option-line').classList.remove('selected');
            }
            this.selectedOption = null;
        }
    }

    createDemoCropInterface(cropMode) {
        const cropInterface = document.getElementById('crop-interface');
        const canvas = document.getElementById('crop-canvas');
        const cropBox = document.getElementById('crop-box');
        
        if (!cropInterface || !canvas || !cropBox) {
            this.showError('Please upload an image first to use crop functionality.');
            return;
        }
        
        // Create a demo colored canvas to show crop functionality
        const ctx = canvas.getContext('2d');
        canvas.width = 400;
        canvas.height = 300;
        canvas.style.width = '400px';
        canvas.style.height = '300px';
        
        // Draw a demo gradient background
        const gradient = ctx.createLinearGradient(0, 0, 400, 300);
        gradient.addColorStop(0, '#28a745');
        gradient.addColorStop(1, '#20c997');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 400, 300);
        
        // Add text indicating it's a demo
        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Upload an image to crop', 200, 150);
        ctx.font = '14px Arial';
        ctx.fillText('This is a demo interface', 200, 180);
        
        // Setup crop box
        const boxSize = 120;
        const x = (400 - boxSize) / 2;
        const y = (300 - boxSize) / 2;
        
        cropBox.style.left = x + 'px';
        cropBox.style.top = y + 'px';
        cropBox.style.width = boxSize + 'px';
        cropBox.style.height = boxSize + 'px';
        
        // Apply circle style for circle crop
        if (cropMode === 'crop-circle') {
            cropBox.classList.add('circle');
        } else {
            cropBox.classList.remove('circle');
        }
        
        // Show interface
        cropInterface.style.display = 'flex';
        
        // Setup interaction
        this.setupCropInteraction();
    }
}

// Initialize the application when DOM is loaded
let imageProcessor;
document.addEventListener('DOMContentLoaded', () => {
    imageProcessor = new ImageProcessor();
});

// Handle file size error from server
window.addEventListener('error', (e) => {
    if (e.message.includes('413')) {
        const processor = new ImageProcessor();
        processor.showError('File too large. Maximum size is 16MB.');
    }
});
